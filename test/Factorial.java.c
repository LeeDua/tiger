// This is automatically generated by the Tiger compiler.
// Do NOT modify!
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void *Tiger_new (void *vtable, int size);
int System_out_println (int i);

// structures
struct Factorial
{
  struct Factorial_vtable *vptr;
};
struct Fac
{
  struct Fac_vtable *vptr;
};
// vtables structures
struct Factorial_vtable
{
};

struct Fac_vtable
{
  int (*ComputeFac)();
};


// vtable ptr and init method decls
struct Factorial_vtable Factorial_vtable_;
struct Factorial_vtable * Factorial_vtable_ptr;
void* get_Factorial_vtable_();
struct Fac_vtable Fac_vtable_;
struct Fac_vtable * Fac_vtable_ptr;
void* get_Fac_vtable_();

// methods
int Fac_ComputeFac(struct Fac * this, int num)
{
  int num_aux;
  struct Fac * x_1;

  if (num < 1)
    num_aux = 1;
  else
    num_aux = num * (x_1=this, x_1->vptr->ComputeFac(x_1, num - 1));
  return num_aux;
}

// vtable get methods
void* get_Factorial_vtable_(){
  if(Factorial_vtable_ptr== NULL){
    struct Factorial_vtable temp = 
      {
      };
    memcpy(&Factorial_vtable_, &temp, sizeof(temp));
    int equal = (int)memcmp(&Factorial_vtable_, &temp, sizeof(temp));
    if(equal != 0){
      printf("Memory copy error: buffer polluted\n");
      exit(-2);
    }
    Factorial_vtable_ptr = &Factorial_vtable_;
  }
  return (void*)(Factorial_vtable_ptr);
}

void* get_Fac_vtable_(){
  if(Fac_vtable_ptr== NULL){
    struct Fac_vtable temp = 
      {
        Fac_ComputeFac,
      };
    memcpy(&Fac_vtable_, &temp, sizeof(temp));
    int equal = (int)memcmp(&Fac_vtable_, &temp, sizeof(temp));
    if(equal != 0){
      printf("Memory copy error: buffer polluted\n");
      exit(-2);
    }
    Fac_vtable_ptr = &Fac_vtable_;
  }
  return (void*)(Fac_vtable_ptr);
}


// main method
int Tiger_main ()
{
  struct Fac * x_0;
  System_out_println ((x_0=((struct Fac*)(Tiger_new (get_Fac_vtable_(), sizeof(struct Fac)))), x_0->vptr->ComputeFac(x_0, 10)));
  return 0;
}




